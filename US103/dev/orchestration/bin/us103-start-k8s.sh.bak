#!/usr/bin/env bash

# us103-start-k8s.sh
# Starts Kubernetes cluster VMs listed in a vars file and uncordons nodes once ready.

set -euo pipefail

# Paths
SCRIPT_NAME=$(basename "$0")
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
VARS_DIR="$SCRIPT_DIR/../vars"
AD_VARS="$VARS_DIR/global/US103-AD-DCs.vars"
GLOBAL_VARS="$VARS_DIR/global/US103-k8s-servers.vars"
OPTIONAL_VARS="$VARS_DIR/optional/${SCRIPT_NAME%.sh}.vars"
START_VM_SCRIPT="$SCRIPT_DIR/../libexec/us103-start-xo-vm.sh"
START_ADDS_SCRIPT="$SCRIPT_DIR/us103-start-adds.sh"

# Validate vars files
for file in "$GLOBAL_VARS" "$AD_VARS"; do
  if [[ ! -f "$file" ]]; then
    echo "‚ùå Missing required file: $file" >&2
    exit 1
  fi
done

# Parse context
context=$(grep -E '^context=' "$GLOBAL_VARS" | head -n1 | cut -d= -f2-)
if [[ -z "$context" ]]; then
  echo "‚ùå 'context=' not found in $GLOBAL_VARS" >&2
  exit 1
fi

# Parse nodes (comma-separated)
nodes_line=$(grep -E '^nodes=' "$GLOBAL_VARS" | head -n1 | cut -d= -f2-)
if [[ -z "$nodes_line" ]]; then
  echo "‚ùå 'nodes=' not found in $GLOBAL_VARS" >&2
  exit 1
fi
IFS=',' read -r -a nodes <<< "$nodes_line"

# Function: check DNS port 53
dns_up() {
  while IFS='=' read -r vm ip; do
    [[ "$vm" =~ ^#.*$ || -z "$vm" ]] && continue
    if timeout 1 bash -c "</dev/tcp/$ip/53" &>/dev/null; then
      return 0
    fi
  done < "$AD_VARS"
  return 1
}

# Ensure DNS is reachable or start AD/DC VMs
echo "üîç Checking DNS reachability..."
if ! dns_up; then
  echo "üö® DNS unreachable. Starting AD/DC servers..."
  "$START_ADDS_SCRIPT"
  echo "‚è≥ Waiting for DNS..."
  until dns_up; do sleep 5; done
  echo "‚úÖ DNS is now reachable"
fi

# Start Kubernetes VMs
echo "üì¶ Starting Kubernetes VMs for context: $context"
for vm in "${nodes[@]}"; do
  echo "‚û°Ô∏è Starting VM: $vm"
  "$START_VM_SCRIPT" "$vm"
done

# Switch kubectl context
echo "üîÑ Switching kubectl to context '$context'..."
kubectl config use-context "$context"

# Wait for API server
echo "‚è≥ Waiting for Kubernetes API server..."
for i in {1..20}; do
  if kubectl cluster-info >/dev/null 2>&1; then
    echo "‚úÖ API server is available"
    break
  fi
  echo "üîÑ API server not ready, retrying..."
  sleep 5
done

# Wait for nodes to become Ready
echo "‚è≥ Waiting for all nodes to be Ready..."
for i in {1..20}; do
  all_ready=true
  for vm in "${nodes[@]}"; do
    status=$(kubectl get node "$vm" --no-headers 2>/dev/null | awk '{print $2}') || status=""
    if [[ "$status" != "Ready" ]]; then
      echo "  - $vm: ${status:-Unknown}" 
      all_ready=false
    fi
  done
  $all_ready && { echo "‚úÖ All nodes Ready"; break; }
  sleep 5
done

# Uncordon any cordoned nodes
echo "üîì Uncordoning nodes if needed..."
for vm in "${nodes[@]}"; do
  if [[ "$(kubectl get node "$vm" -o jsonpath='{.spec.unschedulable}')" == "true" ]]; then
    echo "üîì Uncordoning $vm"
    kubectl uncordon "$vm"
  fi
done

# Start optional standalone VMs (other keys in optional file)
if [[ -f "$OPTIONAL_VARS" ]]; then
  echo "üì¶ Starting optional VMs from $OPTIONAL_VARS"
  while IFS='=' read -r key val; do
    [[ "$key" =~ ^(context|nodes)$ || -z "$key" ]] && continue
    echo "‚û°Ô∏è Starting optional VM: $key"
    "$START_VM_SCRIPT" "$key"
  done < "$OPTIONAL_VARS"
fi

echo "‚úÖ All done."

